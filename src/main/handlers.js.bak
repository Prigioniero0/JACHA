const { ipcMain, app, BrowserWindow } = require('electron');
const { spawn, exec } = require('child_process');
const dns = require('dns');
const util = require('util');
const path = require('path');
const fs = require('fs');
const os = require('os');
const whois = require('whois'); // Will need to ensure this is packed or just use exec whois if available? simpler to use exec for robustness if package fails

const { resolve4, resolve6, resolveMx, resolveTxt, resolveNs, reverse } = require('dns').promises;

module.exports = function registerHandlers() {
    // --- APP CONTROL ---
    ipcMain.on('app:quit', () => {
        app.quit();
    });

    ipcMain.handle('app:version', () => app.getVersion());

    ipcMain.on('app:check-updates', () => {
        const { shell } = require('electron');
        // Open official download pages for dependencies
        shell.openExternal('https://nmap.org/download.html');
        shell.openExternal('https://www.python.org/downloads/');
        shell.openExternal('https://windows.metasploit.com/');
        shell.openExternal('https://hashcat.net/hashcat/');
        shell.openExternal('https://sqlmap.org/');
        shell.openExternal('https://www.openwall.com/john/');
    });

    // --- CLI CONTROL ---
    ipcMain.on('cli:open', (event, arg) => {
        const tool = typeof arg === 'string' ? arg : arg.tool;
        const args = (typeof arg === 'object' && arg.args) ? arg.args : '';

        let command = '';
        let scriptPath = '';

        if (tool === 'nmap') {
            const portablePath = path.join(process.resourcesPath, 'bin', 'nmap', 'nmap.exe');
            if (fs.existsSync(portablePath)) {
                command = `start cmd.exe /k ""${portablePath}" --help"`;
            } else {
                command = `start cmd.exe /k nmap ${args}`;
            }
        } else if (tool === 'sqlmap') {
            // Priority: Portable Bin -> Embedded Resource -> Dev
            const portablePath = path.join(process.resourcesPath, 'bin', 'sqlmap', 'sqlmap.py');
            const embeddedPath = path.join(process.resourcesPath, 'resources', 'sqlmap', 'sqlmap.py');

            if (fs.existsSync(portablePath)) scriptPath = portablePath;
            else if (fs.existsSync(embeddedPath)) scriptPath = embeddedPath;
            else scriptPath = path.resolve('resources/sqlmap/sqlmap.py'); // Dev

            if (scriptPath && fs.existsSync(scriptPath)) {
                command = `start cmd.exe /k python "${scriptPath}" --help`;
            } else {
                command = 'start cmd.exe /k echo SqlMap not found';
            }
        } else if (tool === 'hashcat') {
            const portablePath = path.join(process.resourcesPath, 'bin', 'hashcat', 'hashcat.exe');
            if (fs.existsSync(portablePath)) {
                command = `start cmd.exe /k ""${portablePath}" --help"`;
            } else {
                // If not in bin, assume standard install? OR user has to install it.
                // We'll try just 'hashcat' command expecting it in PATH
                command = `start cmd.exe /k hashcat --help`;
            }
        } else if (tool === 'metasploit') {
            const portablePath = path.join(process.resourcesPath, 'bin', 'metasploit', 'bin', 'msfconsole.bat');
            if (fs.existsSync(portablePath)) {
                command = `start cmd.exe /k "${portablePath}"`;
            } else {
                command = `start cmd.exe /k msfconsole`;
            }
        }

        if (command) {
            // Use spawn to launch 'cmd /c start ...' for reliable detached window
            // command is like: start cmd.exe /k ...
            // We strip 'start ' since we will use 'start' as argument to cmd /c
            // Actually 'start' is a shell builtin. 
            // Best way: spawn('cmd.exe', ['/c', command], { detached: true, stdio: 'ignore' }).unref();

            const child = spawn('cmd.exe', ['/c', command], {
                detached: true,
                stdio: 'ignore',
                windowsHide: false
            });
            child.unref();
        }
    });

    // --- SUBDOMAIN ENUMERATION ---
    // 1. CRT.SH (Passive)
    ipcMain.handle('subdomain:crt', async (event, domain) => {
        const https = require('https');
        return new Promise((resolve, reject) => {
            const options = {
                hostname: 'crt.sh',
                path: `/?q=%.${domain}&output=json`,
                method: 'GET',
                headers: { 'User-Agent': 'Mozilla/5.0' }
            };

            const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                    try {
                        const json = JSON.parse(data);
                        // Extract unique common_names
                        const names = [...new Set(json.map(entry => entry.common_name))];
                        resolve(names);
                    } catch (e) { resolve([]); }
                });
            });

            req.on('error', (e) => resolve([`Error: ${e.message}`]));
            req.end();
        });
    });

    // 2. SUBLIST3R (Active/Python)
    ipcMain.handle('subdomain:sublist3r', async (event, domain) => {
        let scriptPath;
        const portablePath = path.join(process.resourcesPath, 'bin', 'sublist3r', 'sublist3r.py');
        if (fs.existsSync(portablePath)) {
            scriptPath = portablePath;
        } else if (process.env.NODE_ENV === 'development') {
            scriptPath = path.resolve('resources/sublist3r/sublist3r.py');
        } else {
            scriptPath = path.join(process.resourcesPath, 'resources', 'sublist3r', 'sublist3r.py');
        }

        return new Promise((resolve) => {
            const proc = spawn('python', [scriptPath, '-d', domain, '-t', '10', '-o', 'sublist3r_out.txt']);
            let output = '';

            proc.stdout.on('data', d => output += d.toString());
            proc.stderr.on('data', d => output += d.toString());

            proc.on('close', () => {
                resolve(output);
            });
        });
    });

    // --- WINDOW CONTROLS ---
    ipcMain.on('window:minimize', (event) => {
        const win = BrowserWindow.fromWebContents(event.sender) || BrowserWindow.getFocusedWindow();
        if (win) win.minimize();
    });

    ipcMain.on('window:maximize', (event) => {
        const win = BrowserWindow.fromWebContents(event.sender) || BrowserWindow.getFocusedWindow();
        if (win) {
            if (win.isMaximized()) win.unmaximize();
            else win.maximize();
        }
    });

    ipcMain.on('window:close', (event) => {

        const win = BrowserWindow.fromWebContents(event.sender) || BrowserWindow.getFocusedWindow();
        if (win) win.close();
    });

    // --- RECON ---
    ipcMain.handle('recon:whois', async (event, domain) => {
        return new Promise((resolve, reject) => {
            whois.lookup(domain, (err, data) => {
                if (err) resolve(`Error: ${err.message}`);
                else resolve(data);
            })
        });
    });

    // 2. DNS LOOKUP
    ipcMain.handle('recon:dns', async (event, domain) => {
        try {
            // resolveAny is unreliable (ESERVFAIL). We run specific queries.
            const results = {};

            await Promise.allSettled([
                resolve4(domain).then(res => results.A = res).catch(e => results.A = e.code),
                resolve6(domain).then(res => results.AAAA = res).catch(e => results.AAAA = e.code),
                resolveMx(domain).then(res => results.MX = res).catch(e => results.MX = e.code),
                resolveTxt(domain).then(res => results.TXT = res).catch(e => results.TXT = e.code),
                resolveNs(domain).then(res => results.NS = res).catch(e => results.NS = e.code)
            ]);

            return JSON.stringify(results, null, 2);
        } catch (e) { return `Global DNS Error: ${e.message}`; }
    });

    ipcMain.handle('recon:reverse', async (event, ip) => {
        const net = require('net');
        if (!net.isIP(ip)) {
            return 'Error: Invalid IP Address format for Reverse DNS. Please enter a valid IPv4 or IPv6 address.';
        }
        try {
            const res = await reverse(ip);
            return res.join('\n');
        } catch (e) { return `Error: ${e.message}`; }
    });

    // --- NMAP ---
    ipcMain.on('nmap:start', (event, { target, flags }) => {
        // Portable Nmap Check
        const portableNmap = path.join(process.resourcesPath, 'bin', 'nmap', 'nmap.exe');
        let command = 'nmap';
        if (fs.existsSync(portableNmap)) {
            command = `"${portableNmap}"`; // Quote for safety
        }

        const args = [...flags, target];

        // Spawn with shell:true if using quoted path, OR just spawn path
        const proc = spawn(fs.existsSync(portableNmap) ? portableNmap : 'nmap', args);

        proc.stdout.on('data', (data) => event.sender.send('nmap:data', data.toString()));
        proc.stderr.on('data', (data) => event.sender.send('nmap:data', data.toString()));

        proc.on('close', (code) => event.sender.send('nmap:exit', code));
        proc.on('error', (err) => event.sender.send('nmap:data', `Error: ${err.message}`));

        // Store process to kill later if needed? 
        // Simpler IPC: Renderer sends 'nmap:stop'
        ipcMain.once('nmap:stop', () => {
            proc.kill();
        });
    });

    // --- SQLMAP ---
    ipcMain.on('sqlmap:start', (event, { url, options }) => {
        // Locate sqlmap - Check Portable First
        let scriptPath;
        const portablePath = path.join(process.resourcesPath, 'bin', 'sqlmap', 'sqlmap.py');

        if (fs.existsSync(portablePath)) {
            scriptPath = portablePath;
        } else if (process.env.NODE_ENV === 'development') {
            scriptPath = path.resolve('resources/sqlmap/sqlmap.py');
        } else {
            // Correct path: resources/resources/sqlmap/sqlmap.py
            scriptPath = path.join(process.resourcesPath, 'resources', 'sqlmap', 'sqlmap.py');
        }

        const args = [scriptPath, '-u', url, ...options, '--batch'];
        // Assuming python is in PATH
        const proc = spawn('python', args);

        proc.stdout.on('data', (data) => event.sender.send('sqlmap:data', data.toString()));
        proc.stderr.on('data', (data) => event.sender.send('sqlmap:data', data.toString()));
        proc.on('close', (code) => event.sender.send('sqlmap:exit', code));

        ipcMain.once('sqlmap:stop', () => proc.kill());
    });

    // --- SPIDER ---
    ipcMain.handle('spider:start', async (event, { url, depth }) => {
        // "inside the program folder" -> Use a 'scanned' folder next to the executable
        // In dev: project root / scanned. In prod: directory of exe / scanned.
        const baseDir = process.env.NODE_ENV === 'development'
            ? path.join(process.cwd(), 'scanned')
            : path.join(path.dirname(app.getPath('exe')), 'scanned');

        const domain = new URL(url).hostname;
        const dirName = `${domain}_${Date.now()}`;
        const directory = path.join(baseDir, dirName);

        const options = {
            urls: [url],
            directory: directory,
            recursive: true,
            maxDepth: depth,
            filenameGenerator: 'bySiteStructure',
            sources: [
                { selector: 'img', attr: 'src' },
                { selector: 'link[rel="stylesheet"]', attr: 'href' },
                { selector: 'script', attr: 'src' }
            ]
        };

        // Ensure base directory exists
        if (!fs.existsSync(baseDir)) fs.mkdirSync(baseDir, { recursive: true });

        try {
            const scrapeModule = await import('website-scraper');
            const scrape = scrapeModule.default || scrapeModule;

            // Custom Plugin for Logging and Index Generation
            class CyberPlugin {
                apply(registerAction) {
                    let urls = [];

                    registerAction('onResourceSaved', ({ resource }) => {
                        const msg = `Saved: ${resource.filename} (${resource.url})`;
                        event.sender.send('spider:log', msg);
                        urls.push(resource.url);
                    });

                    registerAction('onResourceError', ({ resource, error }) => {
                        const msg = `Error: ${resource.url} - ${error.message}`;
                        event.sender.send('spider:log', msg);
                    });

                    registerAction('afterFinish', () => {
                        const indexContent = urls.join('\n');
                        fs.writeFileSync(path.join(directory, 'urls.txt'), indexContent);
                        event.sender.send('spider:log', `Index created at: ${path.join(directory, 'urls.txt')}`);
                    });
                }
            }

            options.plugins = [new CyberPlugin()];

            event.sender.send('spider:log', `Starting scan of ${url}...`);
            event.sender.send('spider:log', `Output directory: ${directory}`);

            await scrape(options);
            return { success: true, path: directory };
        } catch (e) {
            return { success: false, error: e.message };
        }
    });

    ipcMain.on('spider:open-folder', (event, dirPath) => {
        const { shell } = require('electron');
        if (fs.existsSync(dirPath)) {
            shell.openPath(dirPath);
        }
    });

    // --- DISCOVERY (PING) ---
    ipcMain.handle('discovery:scan', async (event, ips) => {
        // We can run pings in parallel here
        // return array of { ip, alive }
        const results = [];
        const promises = ips.map(ip => new Promise(resolve => {
            // Security: Validate IP format to prevent Command Injection
            if (!/^[\d\.]+$/.test(ip) && !/^[\a-fA-F\d\:]+$/.test(ip)) {
                return resolve({ ip, isAlive: false, error: 'Invalid IP' });
            }
            exec(`ping -n 1 -w 500 ${ip}`, (error, stdout) => {
                resolve({ ip, isAlive: !error && stdout.includes('TTL=') });
            });
        }));

        return Promise.all(promises);
    });

    // --- HASHCAT ---
    ipcMain.on('hashcat:cli', () => {
        const portableHashcat = path.join(process.resourcesPath, 'bin', 'hashcat', 'hashcat.exe');
        if (fs.existsSync(portableHashcat)) {
            exec(`start cmd.exe /k "${portableHashcat}" --help`);
        } else {
            exec('start cmd.exe /k hashcat --help');
        }
    });

    // --- METASPLOIT ---
    ipcMain.on('msf:cli', () => {
        const portableMsf = path.join(process.resourcesPath, 'bin', 'metasploit', 'bin', 'msfconsole.bat'); // Windows batch
        if (fs.existsSync(portableMsf)) {
            exec(`start cmd.exe /k "${portableMsf}"`);
        } else {
            exec('start cmd.exe /k msfconsole');
        }
    });

    // --- LOCAL SERVER ---
    let serverProcess = null;
    ipcMain.handle('server:start', (event, { port, directory }) => {
        if (serverProcess) return { success: false, message: 'Server already running' };

        // Spawn python http.server
        const args = ['-m', 'http.server', port, '--directory', directory];
        serverProcess = spawn('python', args);

        return new Promise((resolve) => {
            // Give it a moment to fail if port is in use
            setTimeout(() => {
                if (serverProcess && serverProcess.exitCode === null) {
                    resolve({ success: true, pid: serverProcess.pid });
                } else {
                    serverProcess = null;
                    resolve({ success: false, message: 'Failed to start. Port busy?' });
                }
            }, 1000);
        });
    });

    ipcMain.handle('server:stop', () => {
        if (serverProcess) {
            serverProcess.kill();
            serverProcess = null;
            return true;
        }
        return false;
    });

    ipcMain.handle('system:ip', () => {
        const nets = os.networkInterfaces();
        const results = {};
        for (const name of Object.keys(nets)) {
            for (const net of nets[name]) {
                // Skip internal and non-ipv4
                if (net.family === 'IPv4' && !net.internal) {
                    if (!results[name]) {
                        results[name] = [];
                    }
                    results[name].push(net.address);
                }
            }
        }
        return results;
    });


    // --- UTILS: EXPORT ---
    ipcMain.handle('app:save-file', async (event, { content, filename }) => {
        const { dialog } = require('electron');
        const { filePath } = await dialog.showSaveDialog({
            defaultPath: filename,
            filters: [{ name: 'Text Files', extensions: ['txt', 'log'] }]
        });

        if (filePath) {
            fs.writeFileSync(filePath, content);
            return true;
        }
        return false;
    });
};
